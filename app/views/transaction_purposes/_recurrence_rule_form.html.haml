= f.fields :recurrence_rule do |rr|
  = rr.label :recurrence
  .input-group
    %label.input-group-label Repeat
    = rr.select :type, RecurrenceRule::TYPES, {}, {class: 'input-group-field'}

  #interval
    .input-group
      %label.input-group-label Every
      = rr.number_field :interval, value: rr.object.new_record? ? 1 : rr.object.interval, min: 1, class: 'input-group-field'
      %label#interval-unit.input-group-label= "#{rr.object.new_record? ? 'day' : {'Daily': 'day', 'Weekly': 'week', 'Monthly': 'month', 'Yearly': 'year'}[rr.object.type]}(s)"

  #weekly{ class: rr.object.new_record? ? 'hide' : "#{'hide' unless rr.object.weekly?}" }
    = weekday_select_bar
    = rr.select :rules, options_for_select(0..6, rr.object.rules), {}, { multiple: true, class: :hide }

  #monthly{ class: rr.object.new_record? ? 'hide' : "#{'hide' unless rr.object.monthly?}" }
    .fieldset
      = radio_button_tag :day_of_month_or_week, :day_of_month, rr.object.new_record? || rr.object.monthly_days_of_month?
      %label Day of Month
      = radio_button_tag :day_of_month_or_week, :day_of_week
      %label Day of Week

      .day_of_month.input-group{ class: rr.object.new_record? ? '' : "#{'hide' unless rr.object.monthly_days_of_month?}" }
        = day_of_month_selection
        = rr.select :rules, options_for_select((1..31).to_a << -1, rr.object.rules), {}, { multiple: true, class: :hide }
      .day_of_week.input-group{ class: rr.object.new_record? ? 'hide' : "#{'hide' unless rr.object.monthly_days_of_week?}" }
        = day_of_week_selection
        = rr.fields :rules do |r|
          - (0..6).to_a.each do |day|
            = r.select day, options_for_select((1..4).to_a << -1, rr.object.rules.try(:[], day)), { include_hidden: false }, { multiple: true, class: :hide } # TODO: Check in db if using include_hidden in case when all selected elements are deselected

  #yearly{ class: rr.object.new_record? ? 'hide' : "#{'hide' unless rr.object.yearly?}" }
    - (1..12).to_a.each do |month|
      %fieldset.fieldset.month.hide{ class: month }
        .input-group
          %label.input-group-label.prev-month{ month: month - 1, disabled: month == 1 } < Previous Month
          %label.input-group-label= Date::MONTHNAMES[month]
          %label.input-group-label.next-month{ month: month + 1, disabled: month == 12 } Next Month >
        = radio_button_tag "day_of_month_or_week_#{month}", :day_of_month, rr.object.new_record? || rr.object.yearly_days_of_month?
        %label Day of Month
        = radio_button_tag "day_of_month_or_week_#{month}", :day_of_week
        %label Day of Week

        .day_of_month.input-group{ class: rr.object.new_record? ? '' : "#{'hide' unless rr.object.yearly_days_of_month?}" }
          = day_of_month_selection(month)
          = rr.fields :rules do |r|
            = r.select month, options_for_select((1..31).to_a << -1, rr.object.rules), {}, { multiple: true, class: :hide }
        .day_of_week.input-group{ class: rr.object.new_record? ? 'hide' : "#{'hide' unless rr.object.yearly_days_of_week?}" }
          = day_of_week_selection(month)
          - (0..6).to_a.each do |day|
            = select_tag "transaction_purpose[recurrence_rule_attributes][rules][#{month}][#{day}]",
              options_for_select((1..4).to_a << -1, rr.object.rules.try(:[], day)), {multiple: true, class: :hide}

  %fieldset.fieldset
    %legend Limit by
    = radio_button_tag :duration_or_count, :duration, rr.object.new_record? || rr.object.duration_bound?
    %label Duration
    = radio_button_tag :duration_or_count, :count
    %label Number of occurrences
    #duration{ class: rr.object.new_record? ? '' : "#{'hide' unless rr.object.duration_bound?}" }
      = rr.label :starts_on
      .input-group
        = rr.datetime_select :starts_on, {order: [:day, :month, :year], date_separator: ' / '}, id: :transaction_purpose_starts_on, class: 'input-group-field small-2'
      = rr.label :ends_on
      .input-group
        = rr.datetime_select :ends_on, {order: [:day, :month, :year], date_separator: ' / '}, id: :transaction_purpose_ends_on, class: 'input-group-field small-2'

    #count{ class: rr.object.new_record? ? 'hide' : "#{'hide' unless rr.object.count_bound?}" }
      = rr.label :count
      = rr.number_field :count, min: 1

  %fieldset.fieldset
    %legend Rules summary
    %label.rules_text
